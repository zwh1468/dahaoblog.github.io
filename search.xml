<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ArrayList源码阅读</title>
      <link href="/dahaoblog.github.io/2021/10/16/arraylist-yuan-ma-yue-du/"/>
      <url>/dahaoblog.github.io/2021/10/16/arraylist-yuan-ma-yue-du/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList源码阅读"><a href="#ArrayList源码阅读" class="headerlink" title="ArrayList源码阅读"></a>ArrayList源码阅读</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></tbody></table></figure><p>首先先看类声明处，ArrayList继承了AbstractList并实现了List、RandomAccess、Cloneable、Serializable接口。</p><p>先看接口，List不用多说、后面三个都是标注接口，RandomAccess表明这个类支持随机访问；Cloneable向Object.clone()方法表明创建实例字段的副本是合法的，如果当前类没有实现Cloneable调用了Object.clone()方法会报 CloneNotSupportedException 异常；Serializable表明类需要序列化需要实现类提供一个static final long 类型的 serialVersionUID 。</p><p>接下来看下类中的几个参数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 用于创建空实例时使用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};<br><span class="hljs-comment">// 当用户创建默认大小实例时使用，elementData指向时添加第一个元素会将容器大小扩容到10</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br><span class="hljs-comment">// 实际存储元素的数组，但为什么是transient呢？后面会说</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <br><span class="hljs-comment">// 当前实际存储元素的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><span class="hljs-comment">// array的最大容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br></code></pre></td></tr></tbody></table></figure><p>看完了参数接着看构造函数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>{<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 用户给定初始容量大于0就初始化</span><br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {<span class="hljs-comment">// 等于0就创建一个空实例</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 小于 0 报设值异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+<br>                                               initialCapacity);<br>        }<br>    }<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>{<br>  <span class="hljs-comment">// 调用默认构造方法会将 elementData 指向 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，后续扩容时会用上这个判断</span><br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>{<br>        elementData = c.toArray();<br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 防止c.toArray不返回Object[]，如果不返回Object[]数组就将整个数组转化一遍</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 添加的空集合替换为空实例</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><p>看完构造方法之后就是ArrayList的重点扩容机制了，ArrayList的扩容机制为原来的1.5倍+1，常常我们大量连续添加元素的时候会频繁产生扩容将原来的数组复制到扩容后的大数组中，降低运行效率，如果我们能提前将我们所需容量预估好就可以极大的提升效率，ensureCapacity()方法就是让我干这个的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>{<br><span class="hljs-comment">// 常规的做一些参数安全校验，扩容大小必须大于原数组容量。当前容器是默认大小空实例是需要判断minCapacity &lt;= DEFAULT_CAPACITY不会小于 DEFAULT_CAPACITY，因为DEFAULTCAPACITY_EMPTY_ELEMENTDATA只是一个标注，只有添加第一个元素的时候才会将elementData大小扩容至DEFAULT_CAPACITY，所以前一个判断minCapacity &gt; elementData.length能通过即使你添加的minCapacity小于10，所以要这里做过滤因为小于10的容量是无意义的，ArrayList扩容时如果指定容纳量小于10会默认将其扩容到10</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; elementData.length <br>            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA<br>                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {<br>            modCount++;<br>            grow(minCapacity);<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><p>看完ensureCapacity接下来看看，当我们执行add方法添加一个元素时会发生什么</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>{<br>        modCount++; <span class="hljs-comment">// 此参数就是fast-fail机制的实现，fast-fail：即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出 ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。在使用list.itrator()进行迭代时可能会发生。</span><br>        add(e, elementData, size);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-keyword">int</span> s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s == elementData.length)  <span class="hljs-comment">// 如果当前实际大小已经等于elementData.length时开始扩容，也表明了ArrayList的负载因子时1</span><br>            elementData = grow();<br>        elementData[s] = e;<br>        size = s + <span class="hljs-number">1</span>;<br>}<br><br><br><span class="hljs-keyword">private</span> Object[] grow() {<br>  <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);<br>}<br><br><span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-keyword">int</span> minCapacity) {<br>   <span class="hljs-keyword">return</span> elementData = Arrays.copyOf(elementData, <span class="hljs-comment">// 要复制的数组</span><br>                                     newCapacity(minCapacity)); <span class="hljs-comment">//新数组的长度</span><br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>{<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length; <br>  <span class="hljs-comment">// 新容量为旧的1.5倍，右移一位相当于除2，为什么用位运算?加快运算效率</span><br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <br>  <span class="hljs-comment">// newCapacity - minCapacity &lt;= 0 发生有两种情况</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt;= <span class="hljs-number">0</span>) {<br>          <span class="hljs-comment">// 当前是默认空实例，还未实例化将elementData.length此时还为0</span><br>            <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>              <span class="hljs-comment">// 在DEFAULT_CAPACITY和minCapacity中取最大值（和前面的呼应了所以支持初始容量小于10是没有意义的）</span><br>                <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>            <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow（溢出）</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>            <span class="hljs-keyword">return</span> minCapacity;<br>        }<br>  <span class="hljs-comment">// 到这表明是正常扩容</span><br>        <span class="hljs-keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 新容量小于MAX_ARRAY_SIZE取newCapacity否则在Integer.MAX_VALUE和MAX_ARRAY_SIZE之间选一个最接近minCapacity的</span><br>            ? newCapacity<br>            : hugeCapacity(minCapacity);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>{<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) <span class="hljs-comment">// minCapacity是原size+1</span><br>            ? Integer.MAX_VALUE<br>            : MAX_ARRAY_SIZE; <br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="为什么MAX-ARRAY-SIZE-Integer-MAX-VALUE-8？"><a href="#为什么MAX-ARRAY-SIZE-Integer-MAX-VALUE-8？" class="headerlink" title="为什么MAX_ARRAY_SIZE=Integer.MAX_VALUE-8？"></a>为什么MAX_ARRAY_SIZE=Integer.MAX_VALUE-8？</h3><p>因为自己作为数组，除了存储数据本身以外，还需要32 bytes的大小来存储对象头（object header）信息。Java每个对象都包含了对象头，HotSpot虚拟机中对象头的大小不会超过32 bytes，所以最大容量减8才不会溢出。</p><p>所以减去对象头大小的32 bytes来源于：</p><p>32 bytes = 8 bytes（Mark Word【用于对象自身的运行时数据存储，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID和偏向时间戳等】 的最大占用） + 8 bytes（Klass Pointer【对象指向它类元数据的指针，JVM通过这个指针长度来确定对象是哪个类的实例】 的最大占用） + 4 bytes（数组长度）+ 8 bytes（引用指针的最大占用：数组中存放的是对象的引用） + 4 bytes（padding：为了方便寻址，JVM要求对象大小要求是8的倍数，不够就填充）</p><p>The maximum size of array to allocate (unless necessary). Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit（作者注释）</p><p>对ArrayList的源码就到这了，我觉得主要是扩容机制，其他方法直接看源码就能看懂。</p>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统原理</title>
      <link href="/dahaoblog.github.io//shu-ju-ku-xi-tong-yuan-li"/>
      <url>/dahaoblog.github.io//shu-ju-ku-xi-tong-yuan-li</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构-字典</title>
      <link href="/dahaoblog.github.io/2021/09/27/redis-di-ceng-shu-ju-jie-gou-zi-dian/"/>
      <url>/dahaoblog.github.io/2021/09/27/redis-di-ceng-shu-ju-jie-gou-zi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="基于哈希实现的结构-字典"><a href="#基于哈希实现的结构-字典" class="headerlink" title="基于哈希实现的结构-字典"></a>基于哈希实现的结构-字典</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字典，又称为符号表、关联数组或映射，是一种用于保存键值对的数据结构。这种数据结构在如java、c++这类语言库中都有对应的实现，而C语言显然是没有的，基于C语言实现的Redis自己实现了这一结构，比如Redis对数据库的增、删、改、查操作也是构建在对字典的操作之上。</p><p>举个例子，当我们执行命令：</p><blockquote><p>redis&gt; SET msg “hello world”</p></blockquote><p>这个命令创建了一个名为msg的键和值为“hello world”的值</p><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> {</span><br>  <span class="hljs-comment">//哈希表数组</span><br>  dictEntry **table;<br>  <br>  <span class="hljs-comment">// 哈希表大小</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>    <br>  <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>  <span class="hljs-comment">// 总是等于 size - 1</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;<br>}dictht;<br></code></pre></td></tr></tbody></table></figure><p>table属性是一个数组，数组中的每一个元素都是指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> {</span><br>  <span class="hljs-comment">// 键</span><br>  <span class="hljs-keyword">void</span> *key;<br>  <br>  <span class="hljs-comment">// 值</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span>{</span><br>    <span class="hljs-keyword">void</span> *val;<br>    uint64_tu64;<br>    int64_ts64;<br>  }v;<br>  <br>  <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>}dictEntry;<br></code></pre></td></tr></tbody></table></figure><p>next属性是用来解决hash冲突的场景（这一点和java的HashMap很相似），v属性保存着键值对中的值，这个值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p><p>举个例子，下图通过next指针将两个索引值相同的键连接在一起（使用头插法）</p><p><img src="01.png" alt="连接在一起的键k1和k0"></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> {</span><br>  <span class="hljs-comment">// 类型特定函数</span><br>  dictType *type;<br>  <br>  <span class="hljs-comment">// 私有数据</span><br>  <span class="hljs-keyword">void</span> *privdata;<br>  <br>  <span class="hljs-comment">// 哈希表</span><br>  dictht ht[<span class="hljs-number">2</span>];<br>  <br>  <span class="hljs-comment">// rehash 索引</span><br>  <span class="hljs-comment">// 当 rehash不在进行时，值为-1</span><br>  <span class="hljs-keyword">int</span> trehashidx;<br>}dict;<br></code></pre></td></tr></tbody></table></figure><ul><li><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p></li><li><p>而privdata属性则保存了需要传给那些类型特定函数的可选参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> {</span><br>  <span class="hljs-comment">// 计算哈希值的函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span></span>;<br>  <br>  <span class="hljs-comment">// 复制键的函数</span><br>  <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);<br>  <br>  <span class="hljs-comment">// 复制值得函数</span><br>  <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj);<br>  <br>  <span class="hljs-comment">// 对比键的函数</span><br>  <span class="hljs-keyword">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key2);<br>  <br>  <span class="hljs-comment">// 销毁键的函数</span><br>  <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata,<span class="hljs-keyword">void</span> *key);<br>  <br>  <span class="hljs-comment">// 销毁值得函数</span><br>  <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata,<span class="hljs-keyword">void</span> *obj);<br>}dictType;<br></code></pre></td></tr></tbody></table></figure><p>​</p></li></ul><p>普通状态下的字典</p><p><img src="02.png" alt="普通状态下的字典"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>实现和java中map一样，程序先根据键值对的键计算出哈希值和索引值，然后再去根据索引值，将包含新键值对的哈希表节点放到哈希数组的指定索引上面，如果发生冲突使用头插法查到链表的头部，这样可以使得插入时的时间复杂度是O(1)</p><blockquote><p>hash = dict-&gt;type-&gt;hashFuncation(k0);</p><p>index = hash&amp;ht[0].sizemask;</p></blockquote><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><ul><li>为字典的ht[1]分配空间，这个哈希表的空间大小取决于要执行的的操作，以及ht[0]当前包含的键值对数量（也就是ht[0].used属性的值）<ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n;</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2n</li></ul></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面；rehash是指重新计算键的哈希值和索引值，然后将键值对放置到ht[1]的指定位置上。</li><li>当ht[0]包含的所有键值对都迁到ht[1]上面后将ht[0]内存释放，再将ht[1]设置为ht[0]，并在ht[1]上创建一个新的hash表为下次rehash做准备。</li></ul><p><img src="03.png"></p><p><img src="04.png"></p><p><img src="05.png"></p><p><img src="06.png"></p><h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><p>当下条件任意一个被满足就会自动开始扩容操作</p><ul><li><p>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</p></li><li><p>服务器目前正在执行BGAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</p><blockquote><p><strong>负载因子 = 哈希表已保存节点数量 / 哈希表大小</strong></p><p>load_factor = ht[0].used / ht[0].size</p></blockquote></li><li><p>当负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p></li></ul><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>值得一提的是rehash操作并不是一次完成的而是渐进完成因为一次性完成大规模的rehash迁移操作可能会造成服务器在一段时间内停止服务给用户造成极其不好的体验，渐进式rehash用上面的dict字典结构中有一个属性trehashidx用来记录rehash索引扩容到了哪里,访问的时候结合ht[0]和ht[1]进行查找。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>字典被广泛用于Redis各种功能包括数据库和哈希键</li><li>Redis中的字典使用哈希表作为底层实现，每个字典有两个哈希表，一个在平时用，一个仅在rehash时使用</li><li>当字典被用作数据库的底层实现，或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值</li><li>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新的哈希表里面，并且这个rehahs过程并不是一次性完成，而是渐进式完成的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构-链表</title>
      <link href="/dahaoblog.github.io/2021/09/26/redis-di-ceng-shu-ju-jie-gou-lian-biao/"/>
      <url>/dahaoblog.github.io/2021/09/26/redis-di-ceng-shu-ju-jie-gou-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表在Redis中的应用非常广泛，列表键的底层实现之一就是链表。在Redis中的发布订阅、慢查询、监视器等功能也都用到了链表。</p><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> {</span><br>  <span class="hljs-comment">// 前置节点</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">prev</span>;</span><br> <br>  <span class="hljs-comment">// 后置节点</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">next</span>;</span><br>  <br>  <span class="hljs-comment">// 节点的值</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>}listNode;<br></code></pre></td></tr></tbody></table></figure><p>通过prev和next组成双端链表，并且使用list结构来操作链表。list结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> {</span><br>  <span class="hljs-comment">// 表头结点</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">head</span>;</span><br> <br>  <span class="hljs-comment">// 表尾结点</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">tail</span>;</span><br>  <br>  <span class="hljs-comment">// 链表所包含的节点数量</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;<br>  <br>  <span class="hljs-comment">// 节点复制函数</span><br>  <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr)<br>  <br>  <span class="hljs-comment">// 节点值释放函数</span><br>  <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">void</span> *key);<br>  <br>  <span class="hljs-comment">// 节点值对比函数</span><br>  <span class="hljs-keyword">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">void</span> *key);<br>}<span class="hljs-built_in">list</span>;<br></code></pre></td></tr></tbody></table></figure><p>Redis的链表实现的特性可以总结如下：</p><p>双端、无环、带表头指针和表尾指针、带链表长度计数器、多态（通过dup、free、match三个属性节点值设置类型特定函数，所以链表可以保存各种不同类型的值）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常规链表操作，附上常用API</p><p><img src="01.jpg" alt="链表常用操作API"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构(SDS动态字符串)</title>
      <link href="/dahaoblog.github.io/2021/09/26/redis-di-ceng-shu-ju-jie-gou-sds-dong-tai-zi-fu-chuan/"/>
      <url>/dahaoblog.github.io/2021/09/26/redis-di-ceng-shu-ju-jie-gou-sds-dong-tai-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h1><p>简单动态字符串（simple dynamic string, SDS) 是 Redis 实现的一个用于保存字符串的数据结构，Redis 没有使用C 语言传统的字符串表示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs redis">redis&gt; set msg "hello, world"<br>创建一个键值对<br>键值对的 键 是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS<br>键值对的 值 是一个字符串对象，对象的底层实现是一个保存着字符串"hello, world" 的 SDS<br></code></pre></td></tr></tbody></table></figure><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>{</span><br>  <span class="hljs-comment">// 记录buf数组中已经使用字节的数量</span><br>  <span class="hljs-comment">// 等于SDS所保存字符串的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <br>  <span class="hljs-comment">// 记录buf数组中未使用字节的数量</span><br>  <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;<br>  <br>  <span class="hljs-keyword">char</span>[] buf;<br>};<br></code></pre></td></tr></tbody></table></figure><p>SDS示例：</p><p><img src="01.jpg" alt="SDS基本示例"></p><ul><li>free为0表示这个SDS没有分配任何未使用空间</li><li>len为5表示这个SDS保存了一个长度为5的字符串</li></ul><h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p>C语言要获取字符串长度的时间复杂度是O(N)，本身并没有像SDS结构中的len来记录长度。我们要知道字符串的长度需要调用strlen函数进行循环遍历，而SDS中因为有len的存在获取字符串长度的时间复杂度是O(1)。</p><h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>字符串长度的复杂度高之外，C语言记录自身长度带来的另一个问题就是容易造成缓冲区溢出。举个例子：strcat函数可以将一个字符串内容拼接在另一个字符串的末尾：</p><blockquote><p>char *strcat(char *dest, const char *src)</p></blockquote><p>函数执行的前提是已经为dest分配了足够的长度来容纳src，否则就会出现缓冲区溢出。</p><h4 id="SDS是如何杜绝缓冲区溢出的？"><a href="#SDS是如何杜绝缓冲区溢出的？" class="headerlink" title="SDS是如何杜绝缓冲区溢出的？"></a>SDS是如何杜绝缓冲区溢出的？</h4><p>在sdshdr中定义的free排上了用场，这里调用的是sdscat函数。当我们执行拼接前首先查看free是否大于等于src如果相等执行函数操作，当free可分配空间不足时候sdscat就会先扩展SDS的空间，然后才执行拼接操作。</p><p>例如，如果我们执行：</p><blockquote><p>sdscat(s,” Cluster”);</p></blockquote><p><strong>拼接之前</strong>:</p><p><img src="02.jpg" alt="拼接操作之前"></p><p><strong>执行sdscat之后</strong>:</p><p><img src="03.jpg" alt="执行sdscat之后"></p><p>可以看到确实扩容了，但是不单是len变成了13连同free的值也变成了13，这个不是bug也不是巧合而是和Redis的分配策略有关。</p><h3 id="减少修改字符串带来的内存重分配次数"><a href="#减少修改字符串带来的内存重分配次数" class="headerlink" title="减少修改字符串带来的内存重分配次数"></a>减少修改字符串带来的内存重分配次数</h3><p>C语言对于包含N个字符串的底层实现总是一个N+1个字符长的数组(保存空字符)。因为C字符串的长度和底层长度存在关联性所有每一次增长或减少字符串时候总是进行一次内存重新分配操作：</p><ul><li>进行增长操作时候需要先扩容，否则会产生缓冲区溢出</li><li>进行截断操作时候需要进行内存释放，否则会发生内存泄漏</li></ul><p>内存重新分配涉及复杂的算法，可能需要执行系统调用，所以通常是一个十分耗时的操作</p><h6 id="SDS的做法：实现了空间预分配和惰性空间释放"><a href="#SDS的做法：实现了空间预分配和惰性空间释放" class="headerlink" title="SDS的做法：实现了空间预分配和惰性空间释放"></a><strong>SDS的做法</strong>：实现了空间预分配和惰性空间释放</h6><p><strong>空间预分配</strong>：当扩展后字符串不足1M那么就会扩展空闲空间free和字符串长度len一样多的空间，如果超过了1M那么就会分配1M的free空间。这使得从先前的最少分配N次空间提升到了最多N次分配</p><p><strong>惰性空间释放</strong>：惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS API 需要缩短 SDS 保存的字符串长度时，不立即使用内存重分配回收，而是使用 free 记录这些字节的数量。不释放多出来的字节空间，如果这时候对 SDS 进行增长操作，这些未使用空间就可以使用。（redis内部头淘汰机制内存不够时会将这些未使用的空间回收）</p><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串必须符合某种编码（比如ASCII），并且除了末尾之外不能包含空字符，这些限制使得C字符串只能保存文本数据，SDS没有这种限制在<strong>Redis不是buf数组来保存字符，而是用它来保存一系列二进制数据</strong> 。通过使用二进制安全的SD不仅使得Redis可以保存文本数据，还可以保存其他的任何数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 使用 C 字符串作为字面量，在大多数情况下，使用 SDS (简单动态字符串) 作为字符串表示，还有对比了 C 字符串与 SDS 的区别，并指出 SDS 的优势等。SDS兼容部分C字符串函数</p><p>下面附上SDS的主要操作API</p><p><img src="04.jpg" alt="SDS主要操作API"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM-JAVA内存模型</title>
      <link href="/dahaoblog.github.io/2020/12/01/jmm/"/>
      <url>/dahaoblog.github.io/2020/12/01/jmm/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h1><h2 id="JMM是什么"><a href="#JMM是什么" class="headerlink" title="JMM是什么"></a>JMM是什么</h2><ul><li>一种规范<ul><li>Java Memory Model</li><li>是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序</li><li>如果没有这样的一个JMM内存模型的规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题</li></ul></li><li>是工具类和关键字的原理</li><li>最重要的三点内容：<strong>重排序、可见性、原子性</strong></li></ul><hr><h2 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h2><ul><li>C语言不存在内存模型的概念</li><li>依赖处理器，不同处理器结果不一样</li><li>无法保证并发安全性</li><li>需要一个标准，让多线程运行结果可预期</li></ul><hr><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li><p>什么是重排序？</p><ul><li>在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格的按照代码语句顺序执行的，它们的顺序改变了，这就是重排序</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jmm.singleton;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reorder</span></span>{<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; ; ) {<br>            i++;<br>            x = <span class="hljs-number">0</span>;<br>            y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>;<br>            b = <span class="hljs-number">0</span>;<br><br>            CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br><br>            Thread one = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                    <span class="hljs-keyword">try</span> {<br>                        latch.countDown();<br>                        latch.await();<br>                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                        e.printStackTrace();<br>                    }<br>                    a = <span class="hljs-number">1</span>;<br>                    x = b;<br>                }<br>            });<br>            Thread two = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                    <span class="hljs-keyword">try</span> {<br>                        latch.countDown();<br>                        latch.await();<br>                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                        e.printStackTrace();<br>                    }<br>                    b = <span class="hljs-number">1</span>;<br>                    y = a;<br>                }<br>            });<br>            two.start();<br>            one.start();<br>            latch.countDown();<br>            one.join();<br>            two.join();<br><br>            String result = <span class="hljs-string">"第"</span> + i + <span class="hljs-string">"次（"</span> + x + <span class="hljs-string">","</span> + y + <span class="hljs-string">")"</span>;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) {<br>                System.out.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                System.out.println(result);<br>            }<br>        }<br>    }<br><br>}<br><br><span class="hljs-comment">///////////////</span><br><br>第<span class="hljs-number">1110</span>次（<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>第<span class="hljs-number">1111</span>次（<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>第<span class="hljs-number">1112</span>次（<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>第<span class="hljs-number">1113</span>次（<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>第<span class="hljs-number">1114</span>次（<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>第<span class="hljs-number">1115</span>次（<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>可以看出到1115次的时候发生了重排序只有当赋值顺序颠倒时才会出现0,0的情况，例如y=a和b=1颠倒了，在执行完y=a后跳到a=1，x=b处后线程切换执行b=1导致出现x=0,y=0的情况</p></li><li><p>对比排序前后的指令优化</p><p>​    <img src="0.png"></p></li><li><p>重排序的3种情况</p><ul><li>编译器优化：包括JVM，JIT编译器等</li><li>CPU指令重排：就算编译器不发生重排，CPU也可能对指令进行重排</li><li>内存的“重排序”：线程A的修改线程B 却看不到</li></ul></li></ul><hr><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul><li><p>代码演示</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jmm.singleton;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldVisibility</span> </span>{<br>     <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span> </span>{<br>        a = <span class="hljs-number">3</span>;<br>        b = a;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{<br>      System.out.println(<span class="hljs-string">"b="</span> + b + <span class="hljs-string">";a="</span> + a);<br>  }<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>          FieldVisibility test = <span class="hljs-keyword">new</span> FieldVisibility();<br>          <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                  <span class="hljs-keyword">try</span> {<br>                      Thread.sleep(<span class="hljs-number">1</span>);<br>                  } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                      e.printStackTrace();<br>                  }<br>                  test.change();<br>              }<br>          }).start();<br><br>          <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                  <span class="hljs-keyword">try</span> {<br>                      Thread.sleep(<span class="hljs-number">1</span>);<br>                  } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                      e.printStackTrace();<br>                  }<br>                  test.print();<br>              }<br>          }).start();<br>      }<br><br>  }<br>    }<br><br>  <span class="hljs-comment">////////////</span><br><br>  b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br><br>  b=<span class="hljs-number">3</span>;a=<span class="hljs-number">1</span><br><br>  b=<span class="hljs-number">3</span>;a=<span class="hljs-number">1</span><br><br>  b=<span class="hljs-number">3</span>;a=<span class="hljs-number">1</span><br><br></code></pre></td></tr></tbody></table></figure></li></ul><p>​    </p><p>上面代码执行时会有b=3;a=1的结果，执行又可能执行完change后改变了b的值给a也赋值了，但由于有一i个读线程和一个写线程，此时a可能对读线程是不可见的(没有将a刷新回主内存当中)导致了这种可见性的错误</p><p>  <img src="1.png"></p><ul><li><p>为什么会有可见性问题</p><ul><li>CPU有多级缓存，导致读的数据过期<ul><li>高速缓存的内容比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层</li><li>线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的</li><li>如果所有核心都只用一个缓存，那么也就不存在内存可见性问题了</li><li>每个核心都会将自己需要的数据读到<strong>独占缓存中</strong>，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值</li></ul></li></ul></li><li><p>什么是<strong>主内存</strong>和<strong>本地内存</strong>？</p><ul><li><p>Java作为高级语言屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不需要关心一级缓存和二级缓存的问题，但是JMM抽象了主内存和本地内存的概念</p></li><li><p>这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器，一级缓存、二级缓存等的抽象</p><p><img src="2.png"></p></li></ul></li><li><p>主内存和本地内存的关系</p><ul><li>JMM有以下规定<ul><li>所有变量都存储在主内存中 ，同时每个线程也有自己独立的工作内存，工作内存中存储的变量是主内存变量的拷贝</li><li>线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中</li><li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成</li></ul></li><li>所有共享变量存在于主内存中，每个线程都有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题</li></ul></li></ul><h3 id="Happens-before原则"><a href="#Happens-before原则" class="headerlink" title="Happens-before原则"></a>Happens-before原则</h3><p><strong>说到可见性就要谈到面试中经常提到的happens-before原则了，下面简单介绍下什么是happens-before</strong></p><ul><li>从JDK5开始，提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</li></ul><p><strong>happens-before原则定义如下：</strong></p><ul><li>如果一个操作happens-before(之前发生)另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><p><strong>与程序员密切相关的happens-before规则如下：</strong></p><ul><li><p>程序顺序规则：如果只有一个线程的操作，那么前一个操作的结果肯定会对后续的操作可见。</p></li><li><p><strong>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。（例如synchroized锁对于同一个锁对象在一个synchroized代码块释放锁对于另一个同步代码块是可见的）</strong></p></li><li><p><strong>volatile变量规则：对一个volatile域的写，happens- before（可见于） 于任意后续对这个volatile域的读。</strong></p><p>​    </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<span class="hljs-comment">// 由于加了这个屏障，JVM不会重排序，由happens-before原则保证对于读线程而言a也变得可见了，可修改上面可见性代码实验</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span> </span>{<br>     a = <span class="hljs-number">3</span>;<br>     b = a;<br>   }<br></code></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>happen-before的传递性原则：  如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作</p></li><li><p>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。(join)</p></li><li><p>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</p></li><li><p>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</p></li><li><p>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用.</p></li></ul><p><strong>工具类Happens-before规则</strong></p><ul><li>线程安全容器get一定能看到在此之前的put等存入动作</li></ul><h3 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h3><ul><li>volatile是什么？<ul><li>volatile是一种同步机制，比synchronized或者Lock类相关类更轻量，因为<strong>使用volatile并不会发生上下文切换等开销很大的行为</strong>（synchronized会导致锁竞争产生上下文切换）</li><li>如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改</li><li>但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的<strong>原子保护</strong>，valotile仅在很有限的场景下才能发挥作用</li></ul></li><li>volatile的适用场合？<ul><li><strong>不适用:a++</strong></li><li>适用场合1：boolean flag，如果一个共享变量自始至终只被各个线程赋值，而没有其他操作，那么就可以用volatile来代替。Synchonized或者代替原子变量，因为赋值是具有原子性的，而volatile又保证了可见性所以线程是安全的</li><li>适用场合2：作为刷新之前变量的触发器</li></ul></li></ul><ul><li>volatile的作用：可见性、禁止重排序<ul><li>可见性<ul><li>读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新的值，写一个volatile属性会立即刷入到主内存</li></ul></li></ul></li><li>volatile和synchronized的关系？<ul><li>volatile在这方面可以看作是轻量版的synchronized：如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，应为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证到线程安全</li></ul></li><li>volatile小结<ul><li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flage；或者作为触发器，实现轻量级同步</li><li>volatile属性的读写操作都是无锁的，他不能代替synchronized，因为他没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上面，所以说他是低成本的</li><li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序</li><li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile属性不会被线程缓存，始终从主存中读取</li><li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其它线程后续对v的读操作</li><li>volatile可以使得long和double的赋值是原子的<ul><li>因为在32位的JVM虚拟机上对于long和double这种64位的操作不是一步到位的而是先赋值32位所以可能会导致原子性的问题</li><li>但是在商用虚拟机中不会出现这样的问题（我们只要了解即可）</li></ul></li></ul></li></ul><h4 id="能保证可见性的措施"><a href="#能保证可见性的措施" class="headerlink" title="能保证可见性的措施"></a>能保证可见性的措施</h4><ul><li>除了volatile可以让变量保证可见性外，synchronized、lock、并发集合、Thread.join()和Thread.start()等都可以保证可见性</li></ul><h4 id="升华对Synchronized的理解"><a href="#升华对Synchronized的理解" class="headerlink" title="升华对Synchronized的理解"></a>升华对Synchronized的理解</h4><ul><li><p>Synchronized不仅保证了原子性，还保证了可见性</p></li><li><p>Synchronized不仅让被保护的代码安全，还保证了在synchronized的后续操作对于其他线程是可见的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldVisibilityABCD</span> </span>{<br><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> d = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-comment">// 保证了abc赋值的线程可见性</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span> </span>{<br>        a = <span class="hljs-number">3</span>;<br>        b = <span class="hljs-number">4</span>;<br>        c = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>            d = <span class="hljs-number">6</span>;<br>        }<br>    }<br>  <br>  <span class="hljs-comment">// 保证了</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>          <span class="hljs-keyword">int</span> aa = a;<br>      }<br>      <span class="hljs-keyword">int</span> bb = b;<br>      <span class="hljs-keyword">int</span> cc = c;<br>      <span class="hljs-keyword">int</span> dd = d;<br><br>      System.out.println(<span class="hljs-string">"b="</span> + b + <span class="hljs-string">";a="</span> + a);<br>  }<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>          FieldVisibilityABCD test = <span class="hljs-keyword">new</span> FieldVisibilityABCD();<br>          <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                  <span class="hljs-keyword">try</span> {<br>                      Thread.sleep(<span class="hljs-number">1</span>);<br>                  } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                      e.printStackTrace();<br>                  }<br>                  test.change();<br>              }<br>          }).start();<br><br>          <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                  <span class="hljs-keyword">try</span> {<br>                      Thread.sleep(<span class="hljs-number">1</span>);<br>                  } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                      e.printStackTrace();<br>                  }<br>                  test.print();<br>              }<br>          }).start();<br>      }<br><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><p>  ​</p><hr><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li><p>什么是原子性？</p><ul><li>指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行</li><li>除long和double之外的基本类型</li><li>所有引用reference赋值操作，不管是32位的机器还是64位的机器</li><li>java.concurrent.Atomic.*包中所有类的原子性操作</li></ul></li><li><p>Java中的原子性操作有哪些？</p></li><li><p>单例模式</p><ul><li><p>有许多种实现方式这里主要展示双重检查实现单例模式</p></li><li><p>代码实例 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jmm.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查懒汉单例模式 延迟加载</span><br><span class="hljs-comment"> * 延迟加载（推荐在工作中使用）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhy</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton6</span> </span>{<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton6 instance = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton6</span><span class="hljs-params">()</span> </span>{<br><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton6 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// 双重检查外部if是为了节省下次获取synchronized带来的性能开销</span><br><span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {<br><span class="hljs-keyword">synchronized</span> (Singleton6.class) {<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {    <span class="hljs-comment">// 防止两个线程进入到此处没有对instance进行检查而导致两次初始化</span><br>instance = <span class="hljs-keyword">new</span> Singleton6();<br>}<br>}<br>}<br><span class="hljs-keyword">return</span> instance;<br>}<br><br>}<br><br><span class="hljs-comment">/// &lt;&lt;Efficient  java&gt;&gt;中指出使用Enum来实现单例是比较好的方式</span><br><span class="hljs-comment">///1、可以防止序列化带来的问题和使用反射机制来破坏单例</span><br><span class="hljs-comment">/// 2、编码简单、java内部机制支持效率高</span><br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><p>工具类的Happens-before原则</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口最大值(Leetcode 239题)</title>
      <link href="/dahaoblog.github.io/2020/11/19/sliding-window-maximum/"/>
      <url>/dahaoblog.github.io/2020/11/19/sliding-window-maximum/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="0.png"></p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​    <strong>第一种</strong>：</p><p>​        暴力法，比较简单通过两层循环来遍历设置 left 和 right进行窗口的定位</p><p>​    </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] num, <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function"></span>{<br>     ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(num.length &lt; <span class="hljs-number">0</span>|| size &gt; num.length||size &lt;= <span class="hljs-number">0</span>){<br>        <span class="hljs-keyword">return</span> list;<br>    }<br>    <span class="hljs-keyword">int</span> right = size - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>     <br>    <br>    <span class="hljs-keyword">while</span>(right &lt; num.length){<br>        <span class="hljs-keyword">int</span> max = num[index++];<br>        <span class="hljs-keyword">while</span>(index &lt;= right){<br>            max = max &gt; num[index]  ? max : num[index];<br>            index++;<br>        }<br>        right++;<br>        left++;<br>        index=left;<br>         <br>        list.add(max);<br>    }<br>    <span class="hljs-keyword">return</span> list;<br>}<br></code></pre></td></tr></tbody></table></figure><p>​    <strong>第二种</strong>：</p><p>​        通过双向队列进行，队列维持队头元素每次都是队列中的最大值。</p><p>​        每次往队列尾部插入，当前遍历元素和队尾元素比较如果比队尾大就把队尾元素弹出删除</p><p>​        当i&gt;=size-1时画出第一个窗口，每次把队头插入到最终返回数组中，插入前判断队头元素是否在当前滑窗有效范围</p><p>​    </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单调队列，保证对头元素是整个队列的最大值</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] num, <span class="hljs-keyword">int</span> size)</span></span>{<br> ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br> <span class="hljs-keyword">if</span>(size &lt; <span class="hljs-number">1</span> || size &gt; num.length) {<br> <span class="hljs-keyword">return</span> list;<br> }<br> <br> <br> Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br> <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num.length; i++) {<br><span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; num[deque.peekLast()] &lt; num[i]) {  <span class="hljs-comment">// 当前元素比队尾元素大就把队尾元素清除</span><br>deque.pollLast();<br>}<br><br>deque.addLast(i);<span class="hljs-comment">// 记录下标</span><br><br><span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i-size) {  <span class="hljs-comment">//队头元素超过当前窗口范围把队头弹出删除</span><br>deque.pollFirst();<br>}<br><br><span class="hljs-keyword">if</span>(i &gt;= size-<span class="hljs-number">1</span>) { <span class="hljs-comment">// 滑窗块范围</span><br>list.add(num[deque.peekFirst()]);<span class="hljs-comment">//当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span><br>}<br> }<br> <span class="hljs-keyword">return</span> list;<br> }<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Synchronized</title>
      <link href="/dahaoblog.github.io/2020/11/14/synchronized/"/>
      <url>/dahaoblog.github.io/2020/11/14/synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>​    同步（英语：Synchronization），指对在一个系统中所发生的事件（event）之间进行协调，一个资源同时只能被一个线程所拥有</p><p><strong>Synchronized的作用</strong></p><p>​    能够保证在<strong>同一时刻</strong>最多只有一个线程执行该段代码，以达到并发安全的效果</p><h2 id="Synchronized的两个用法"><a href="#Synchronized的两个用法" class="headerlink" title="Synchronized的两个用法"></a><strong>Synchronized的两个用法</strong></h2><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><ul><li><p>包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）</p><ul><li>注意方法锁锁的是当前this对象，如果是两个实例对象的话是不会影响的。</li><li>同步代码块锁可以自己指定对象，不同的对象锁之间不会相互影响，代码块范围越小越好</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> SynchroizationMethod instance = <span class="hljs-keyword">new</span> SynchroizationMethod();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>method();<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>{<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始运行"</span>);<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"结束运行"</span>);<br>}<br><br><span class="hljs-comment">// 不加锁的情况下   // 在method方法上加上synchronized</span><br>Thread-<span class="hljs-number">1</span>开始运行Thread-<span class="hljs-number">0</span>开始运行<br>Thread-<span class="hljs-number">0</span>开始运行Thread-<span class="hljs-number">0</span>结束运行<br>Thread-<span class="hljs-number">0</span>结束运行Thread-<span class="hljs-number">1</span>开始运行<br>Thread-<span class="hljs-number">1</span>结束运行Thread-<span class="hljs-number">1</span>结束运行<br></code></pre></td></tr></tbody></table></figure><p>​</p></li></ul><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><ul><li>指synchronized修饰静态的方法或指定锁为Class对象</li><li>java类可能有多个对象但是只有一个Class对象<ul><li>形式一：在static方法上加synchronized</li><li>形式二：使用synchronized（*.class）方式</li></ul></li><li>类锁锁后访问该类所有的实例方法都会是同步的</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>method();<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>{<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"开始运行"</span>);<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"结束运行"</span>);<br>      <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">        synchronized(SynchronizedClass.class){</span><br><span class="hljs-comment">           System.out.println(Thread.currentThread().getName() + "开始运行");</span><br><span class="hljs-comment">           Thread.sleep(3000);</span><br><span class="hljs-comment">           System.out.println(Thread.currentThread().getName() + "结束运行");</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">      **/</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>SynchronizedClass instace1 = <span class="hljs-keyword">new</span> SynchronizedClass();<br>SynchronizedClass instace2 = <span class="hljs-keyword">new</span> SynchronizedClass();<br><span class="hljs-keyword">new</span> Thread(instace1).start();<br><span class="hljs-keyword">new</span> Thread(instace2).start();<br>}<br><br>}<br>  <span class="hljs-comment">// 运行结果</span><br>  Thread-<span class="hljs-number">0</span>开始运行<br>  Thread-<span class="hljs-number">0</span>结束运行<br>  Thread-<span class="hljs-number">1</span>开始运行<br>  Thread-<span class="hljs-number">1</span>结束运行<br></code></pre></td></tr></tbody></table></figure><h4 id="三点核心思想"><a href="#三点核心思想" class="headerlink" title="三点核心思想"></a>三点核心思想</h4><ul><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待</li><li>每个实例都对应有自己的一把锁，不同实例之间互不影响；例：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用的一把锁</li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁</li></ul><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p><strong>什么是可重入？</strong></p><ul><li><p>指的是同一线程的外层函数获得锁之后，内层函数可以再次获得锁</p><ul><li><p>好处：避免死锁，提升封装性</p></li><li><p>粒度：线程而非调用</p><ul><li>情况1：一个方法是可重入的</li><li>情况2：可重入不要求是同一个方法</li><li>情况3：可重入不要求是同一个类中</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> synchronization;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedReentrant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>method01();<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>System.out.println(<span class="hljs-string">"method01"</span>);<br>method02();<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {<br>System.out.println(<span class="hljs-string">"method02"</span>);<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>SynchronizedReentrant synchronizedReentrant = <span class="hljs-keyword">new</span> SynchronizedReentrant();<br><span class="hljs-keyword">new</span> Thread(synchronizedReentrant).start();<br>}<br>}<br><span class="hljs-comment">//运行结果</span><br>method01<br>method02<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人不释放，我将永远等待下去形成死锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">if</span>(<span class="hljs-string">"Thread-0"</span>.equals(Thread.currentThread().getName())) {<br>method1();<br>}<span class="hljs-keyword">else</span> {<br>method2();<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">synchronized</span> (lock1) {<br><span class="hljs-keyword">try</span> {<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>} <span class="hljs-keyword">catch</span> (InterruptedException e) {<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>}<br><span class="hljs-keyword">synchronized</span> (lock2) {<br>}<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">synchronized</span> (lock2) {<br><span class="hljs-keyword">try</span> {<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>} <span class="hljs-keyword">catch</span> (InterruptedException e) {<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>}<br><span class="hljs-keyword">synchronized</span> (lock1) {<br>}<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><span class="hljs-keyword">new</span> Thread(instance).start();<br><span class="hljs-keyword">new</span> Thread(instance).start();<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>加锁和释放锁的原理：现象、时机、深入JVM看字节码</p><ul><li><p>从一个简单的java类字节码来看</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">a</span></span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>){<br>}<br>    }   <br>}<br><br><span class="hljs-comment">// 编译成字节码后关键部分</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: dup<br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: monitorenter<br>         <span class="hljs-number">4</span>: aload_1<br>         <span class="hljs-number">5</span>: monitorexit<br>         <span class="hljs-number">6</span>: goto          <span class="hljs-number">14</span><br>         <span class="hljs-number">9</span>: astore_2<br>        <span class="hljs-number">10</span>: aload_1<br>        <span class="hljs-number">11</span>: monitorexit<br>        <span class="hljs-number">12</span>: aload_2<br>        <span class="hljs-number">13</span>: athrow<br>        <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span><br>      Exception table:<br>         from    to  target type<br>             <span class="hljs-number">4</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span>   any<br>             <span class="hljs-number">9</span>    <span class="hljs-number">12</span>     <span class="hljs-number">9</span>   any<br>      LineNumberTable:<br>        line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">4</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">5</span>: <span class="hljs-number">14</span><br></code></pre></td></tr></tbody></table></figure><p>可以从上字节码看出synchronized是通过monitor来实现同步的，有两个monitorexit是因为可能对应多种退出方式如正常退出和发生异常退出，一个monitorenter对应多个monitorexit</p></li></ul></li><li><p>可重入原理：加锁次数计数器</p><ul><li>JVM负责跟踪对象被加锁的次数</li><li>线程第一次给对象加锁的时候，计数变为1.每当这个相同的线程在此对象上再次获得锁时，计数器会递增（这就是为何知道当前代码同步块是否被阻塞，当为0释放锁后才能有机会获得锁）</li><li>每当任务离开时，计数器递减，当计数为0的时候，锁被完全释放</li></ul></li><li><p>保证可见性的原理：内存模型</p><p><img src="0.jpg" alt="java内存模型"></p></li></ul><h3 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h3><ul><li>效率低：锁释放的情况少、试图获得锁不能设定超时、不能中断正在试图获得锁的线程</li><li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的</li><li>无法知道是否成功获得锁</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Java字节码</title>
      <link href="/dahaoblog.github.io/2020/09/07/qian-xi-java-zi-jie-ma/"/>
      <url>/dahaoblog.github.io/2020/09/07/qian-xi-java-zi-jie-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析Java字节码"><a href="#浅析Java字节码" class="headerlink" title="浅析Java字节码"></a>浅析Java字节码</h1><h2 id="java开发过程"><a href="#java开发过程" class="headerlink" title="java开发过程"></a>java开发过程</h2><ul><li>Java开发过程<ul><li>编写阶段：采用各种编译工具，编写.java文件</li><li>编译阶段：采用javac.exe对.java文件编译，产生.class文件</li><li>运行阶段：采用java.exe加载.class文件运行</li></ul></li></ul><h2 id="学习Class文件"><a href="#学习Class文件" class="headerlink" title="学习Class文件"></a>学习Class文件</h2><ul><li>.class文件的学习<ul><li>字节码文件结构<ul><li>了解class文件的内部各个模块的组成</li></ul></li><li>字节码生成<ul><li>javac、编译器API、其他编译器API</li></ul></li><li>字节码操作<ul><li>利用工具对字节码进行查看和编辑</li></ul></li><li>字节码增强<ul><li>使用Instrumen对字节码进行转换</li></ul></li><li>字节码反编译和混淆</li></ul></li></ul><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>​    java编译后成功class字节码文件，使用IDE打开以16进制的方式显示出来</p><ul><li><p>前4个字节为魔数，十六进制表示为<strong>0XCAFEBABE</strong>，表示该文件为java</p><ul><li><strong>0XCAFEBABE</strong>转码后有咖啡的意思，结合java的logo可得知意思</li><li>为什么在文件内标识，不是可以用扩展名标识吗？<ul><li>因为扩展名是可以修改的，在文件内部定义使文件更具有安全性</li></ul></li></ul></li><li><p>Constant pool常量池主要存放两大类常量</p><ul><li>字面量<ul><li>如文本字符串、final的常量值等</li></ul></li><li>符号引用<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li>魔数后面两位是常量池的长度，因为常量池的大小不是固定的</li></ul></li><li><p>访问标志</p><ul><li><p>常量池结束后的两个字节，描述该Class是类还是接口，以及是否被public、abstract、final等修饰符修修饰</p></li><li><table><thead><tr><th align="center"><strong>ACC_PUBLIC</strong></th><th align="center"><strong>0X0001</strong></th><th align="center"><strong>public类</strong></th></tr></thead><tbody><tr><td align="center"><strong>ACC_FINAL</strong></td><td align="center"><strong>0X0010</strong></td><td align="center"><strong>final类</strong></td></tr><tr><td align="center"><strong>ACC_SUPER</strong></td><td align="center"><strong>0X0020</strong></td><td align="center"><strong>使用增强方法调用父类方法</strong></td></tr><tr><td align="center"><strong>ACC_INTERFACE</strong></td><td align="center"><strong>0X0200</strong></td><td align="center"><strong>接口</strong></td></tr><tr><td align="center"><strong>ACC_ABSTRACT</strong></td><td align="center"><strong>0x0400</strong></td><td align="center"><strong>抽象类</strong></td></tr><tr><td align="center"><strong>ACC_SYNTHETIC</strong></td><td align="center"><strong>0X1000</strong></td><td align="center"><strong>由编译器产生的类、无源码</strong></td></tr><tr><td align="center"><strong>ACC_ANNOTATION</strong></td><td align="center"><strong>0x2000</strong></td><td align="center"><strong>注解</strong></td></tr><tr><td align="center"><strong>ACC_ENUM</strong></td><td align="center"><strong>0x4000</strong></td><td align="center"><strong>枚举</strong></td></tr></tbody></table></li></ul></li></ul><h2 id="Class文件-类索引、父类索引与接口索引集合"><a href="#Class文件-类索引、父类索引与接口索引集合" class="headerlink" title="Class文件-类索引、父类索引与接口索引集合"></a>Class文件-类索引、父类索引与接口索引集合</h2><ul><li>类索引<ul><li>访问标志后的两个字节，描述的是当前类的全限定名</li><li>这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池接口中找到这个类的全限定名</li></ul></li><li>父类索引<ul><li>当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值</li></ul></li><li>接口索引集合<ul><li>父类名称后为两个字节的接口计数器，描述了该类或父类实现的接口数量</li><li>紧接着的n个字节是所有接口名称的字符串常量池中的索引值</li></ul></li></ul><h2 id="Class文件-字段表"><a href="#Class文件-字段表" class="headerlink" title="Class文件-字段表"></a>Class文件-字段表</h2><ul><li><p>字段表</p><ul><li>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量</li><li>字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info</li></ul><table><thead><tr><th align="center">字段表计数器</th><th align="center">权限修饰符</th><th align="center">字段名索引</th><th align="center">描述符索引</th><th align="center">属性个数</th><th align="center">属性列表</th></tr></thead><tbody><tr><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td></tr></tbody></table><p>​                 fields_count</p></li></ul><h2 id="Class文件-方法表"><a href="#Class文件-方法表" class="headerlink" title="Class文件-方法表"></a>Class文件-方法表</h2><ul><li><p>方法表</p><ul><li><p>字段表结束后为方法表，方法表也是由两部分组成</p><ul><li>第一部分为两个字节描述方法的个数</li><li>第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性</li></ul><table><thead><tr><th align="center">方法计数器</th><th align="center">权限修饰符</th><th align="center">方法名索引</th><th align="center">描述符索引</th><th align="center">属性个数</th><th align="center">属性列表</th></tr></thead><tbody><tr><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">2字节</td><td align="center">n字节</td></tr></tbody></table><p>![](class structure.jpeg)</p><p>​</p></li></ul></li></ul><p>关于字节码更详细的知识可以看这篇文章 <a href="https://blog.csdn.net/u011810352/article/details/80316870">从一个class文件深入理解Java字节码结构</a></p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
